前面预防死锁的方案都是在控制进程中已经知道所有它将要访问的共有资源了，
如上一题的exchange过程。
但是这个预防死锁的方法却不能适用于在调用过程后才知道要访问哪个共有资源的情况
（如根据先前传进来的共有资源再决定接下来要访问的资源）。
比如在银行系统中，一个账户可以设定其关联账户，在本账户余额不足时向关联账户请求。
有账户A，设其关联账户为B；B的关联账户再设置成A。
当A，B都余额不足时，同时有两个用户分别在A，B账户中取钱；
A由于余额不足再向B申请，B由于金额不足向A申请，而这时A要等待向B申请的结果；
这样就形成了死锁。
（当然现实中可能不会允许这种互相关联的情况出现，关联的账户必须有主有从，
  从属账户不能被主账户所关联。）
