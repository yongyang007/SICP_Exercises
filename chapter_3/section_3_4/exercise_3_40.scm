(define x 10)

(parallel-execute (lambda () (set! x (* x x)))
                  (lambda () (set! x (* x x x))))

;; 上述过程中共有5次对x的读取，2次对x的设置
;; 我们分别把读取标记为R1~R5，设置标记为S1和S2
;; 如果读取和设置过程没有进行串行化的话，会出现下面的几种结果：
;; 100：R1、R2读取x的结果都为10，S1在最后将x设置为100
;; 1000：R3~R5读取x的结果都为10，S2在最后将x设置为1000
;; 10000：R1读取到10，R2读取到由S2设置成的1000，S1将x设置为10 * 1000 = 10000
;; 10000：R3、R4读取到10，R5读取到由S1设置成的100，S2将x设置成10 * 10 * 100 = 10000
;; 100000：R3读取到10，R4、R5读取到由S1设置成的100，S2将x设置成10 * 100 * 100 = 100000
;; 1000000：相当于(R1 R2 S1)和(R3 R4 R5 S2)两组读写过程串行化，因为指数计算满足(x^a)^b = (x^b)^a，所以结果一致，都是1000000

(define x 10)

(define s (make-serializer))

(parallel-execute (s (lambda () (set! x (* x x))))
                  (s (lambda () (set! x (* x x x)))))

;; 结果只有1000000
